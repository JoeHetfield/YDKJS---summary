# 文法

## 语句与表达式

语句就是句子，表达式就是短语，而操作符就是连词/标点。

### 语句完成值

所有语句都有完成值。

```js
var b = a
```

`b = a`赋值表达式给出的结果是被赋予的值（上面的`18`），但是`var`语句本身给出的结果是`undefined`。为什么？因为在语言规范中`var`语句就是这么定义的。如果你在你的控制台中敲入`var a = 42`，你会看到`undefined`被报告而不是`42`。

任何普通的`{ .. }`块儿都有一个完成值，即它所包含的最后一个语句/表达式的完成值。

```js
var b;

if (true) {
	b = 4 + 38;
}
```

它报告`42`，因为`42`是`if`块儿的完成值，它取自`if`的最后一个复制表达式语句`b = 4 + 38`。一个块儿的完成值就像隐含地返回块儿中最后一个语句的值。

不能以任何简单的语法/文法来捕获一个语句的完成值并将它赋值给另一个变量。

使用臭名昭著的`eval(..)`：

```js
var a, b;

a = eval( "if (true) { b = 4 + 38; }" );

a;	// 42
```

称为“do表达式”的ES7提案：

```js
var a, b;

a = do {
	if (true) {
		b = 4 + 38;
	}
};

a;	// 42
```

### 表达式副作用

最常见的（可能）带有副作用的表达式的例子是函数调用表达式：

```js
function foo() {
	a = a + 1;
}

var a = 1;
foo();		// 结果：`undefined`，副作用：改变 `a`
```

其他的副作用表达式：

```js
var a = 42;
var b = a++;

a;	// 43
b;	// 42
```

表达式`a++`有两个分离的行为。首先，它返回`a`的当前值，也就是`42`（然后它被赋值给`b`）。但 接下来，它改变`a`本身的值，将它增加1。

```js
var a = 42;
var b = (a++);

a;	// 43
b;	// 42
```

`( )`本身不会像我们希望的那样，定义一个新的被包装的表达式，而它会在`a++`表达式的后副作用之后求值。

```js
var a = 42, b;
b = ( a++, a );

a;	// 43
b;	// 43
```

`,`语句序列逗号操作符。这个操作符允许你将多个独立的表达式语句连成一个单独的语句。表达式`a++, a`意味着第二个`a`语句表达式会在第一个`a++`语句表达式的后副作用之后进行求值，这表明它为`b`的赋值返回`43`。

`++a++`将会得到一个`ReferenceError`错误，因为有副作用的操作符要求一个变量引用来作为它们副作用的目标。对于`++a++`来说，`a++`这部分会首先被求值（因为操作符优先级），它会给出`a`在递增之前的值。但然后它试着对`++42`求值，这将会给出相同的`ReferenceError`错误，因为`++`不能直接在`42`这样的值上施加副作用。

另一个副作用操作符的例子是`delete`,如果被请求的操作是合法/可允许的，`delete`操作符的结果值为`true`，否则结果为`false`。但是这个操作符的副作用是它移除了属性（或数组值槽）：

```js
var obj = {
	a: 42
};

obj.a;			// 42
delete obj.a;	// true
obj.a;			// undefined
```

副作用操作符的最后一个例子，可能既是明显的也是不明显的，是`=`赋值操作符：

```js
var a;

a = 42;		// 42
a;			// 42
```

如果我们检视语句`a = 42`的结果值，会发现它就是刚刚被赋予的值（`42`），所以向`a`赋予的相同的值实质上是一种副作用。这种赋值表达式（语句）得出被赋予的值的行为，主要在链式赋值上十分有用：

```js
var a, b, c;

a = b = c = 42;
```

一个开发者们常犯的错误是将链式赋值写成`var a = b = 42`这样。虽然这看起来是相同的东西，但它不是。如果这个语句发生在没有另外分离的`var b`（在作用域的某处）来正式声明它的情况下，那么`var a = b = 42`将不会直接声明`b`。根据`strict`模式的状态，它要么抛出一个错误，要么无意中创建一个全局变量。

### 上下文规则

#### `{ .. }` 大括号

##### 对象字面量

我们怎么知道这是一个`object`字面量？因为`{ .. }`是一个被赋予给`a`的值。

##### 标签

```js
{
	foo: bar()
}
```

这里的`{ .. }`代码块儿在功能上差不多与附着在一些语句后面的代码块儿是相同的，比如`for`/`while`循环，`if`条件，等等。`foo`是语句`bar()`（这个语句省略了末尾的`;`）的标签。如果JavaScript有一个`goto`语句，那么在理论上你就可以说`goto foo`并使程序的执行跳转到代码中的那个位置。JS的确支持一种有限的，特殊形式的`goto`：标签跳转。`continue`和`break`语句都可以选择性地接受一个指定的标签，在这种情况下程序流会有些像`goto`一样“跳转”：

```js
// 用`foo`标记的循环
foo: for (var i=0; i<4; i++) {
	for (var j=0; j<4; j++) {
		// 每当循环相遇，就继续外层循环
		if (j == i) {
			// 跳到被`foo`标记的循环的下一次迭代
			continue foo;
		}

		// 跳过奇数的乘积
		if ((j * i) % 2 == 1) {
			// 内层循环的普通（没有被标记的） `continue`
			continue;
		}

		console.log( i, j );
	}
}
// 1 0
// 2 0
// 2 1
// 3 0
// 3 2
```

`continue foo`不意味着“走到标记为‘foo’的位置并继续”，而是，“继续标记为‘foo’的循环，并进行下一次迭代”。所以，它不是一个真正的随意的`goto`。也许标签跳转的一个稍稍更有用的形式是，使用`break __`从一个内部循环里面跳出外部循环。没有带标签的`break`，同样的逻辑有时写起来非常尴尬：

```js
// 用`foo`标记的循环
foo: for (var i=0; i<4; i++) {
	for (var j=0; j<4; j++) {
		if ((i * j) >= 3) {
			console.log( "stopping!", i, j );
			// 跳出被`foo`标记的循环
			break foo;
		}

		console.log( i, j );
	}
}
// 0 0
// 0 1
// 0 2
// 0 3
// 1 0
// 1 1
// 1 2
// stopping! 1 3
```

`break foo`不意味着“走到‘foo’标记的位置并继续”，而是，“跳出标记为‘foo’的循环/代码块儿，并继续它后面的部分”。一个标签也可以用于一个非循环的块儿，但只有`break`可以引用这样的非循环标签。你可以使用带标签的`break ___`跳出任何被标记的块儿，但你不能`continue ___`一个非循环标签，也不能用一个不带标签的`break`跳出一个块儿。

实际上完全合法的JSON值`{"a":42}`本身将会抛出一个JS错误，因为它被翻译为一个带有非法标签的语句块儿。但是`foo({"a":42})`是一个合法的JS，因为在它里面，`{"a":42}`是一个被传入`foo(..)`的`object`字面量值。所以，更合适的说法是，JSON-P使JSON成为合法的JS文法！

##### 块儿

```js
[] + {}; // "[object Object]"
{} + []; // 0
```

`{}`出现在`+`操作符的表达式中，因此被翻译为一个实际的值（一个空`object`）。`[]`被强制转换为`""`因此`{}`也会被强制转换为一个`string`：`"[object Object]"`。

`{}`被翻译为一个独立的`{}`空代码块儿（它什么也不做）。块儿不需要分号来终结它们，所以这里缺少分号不是一个问题。最终，`+ []`是一个将`[]`明确强制转换为`number`的表达式，而它的值是`0`

### 操作符优先级

```js
var a = 42, b;
b = a++, a;

a;	// 43
b;	// 42
```

`,`操作符要比`=`操作符的优先级低。所以，`b = a++, a`被翻译为`(b = a++), a`。因为`a++`拥有后副作用，赋值给`b`的值就是在`++`改变`a`之前的值`42`。如果你将要把`,`作为一个语句序列操作符使用，那么知道它实际上拥有最低的优先级是很重要的。任何其他的操作符都将要比`,`结合得更紧密。

对于`&&`和`||`两个操作符来说，如果左手边的操作数足够确定操作的结果，那么右手边的操作数将不会被求值。故而有了“短接”（如果可能，它就会取捷径退出）这个名字。

a && b || c ? c || b ? a : c && b : a 相当于 (a && b || c) ? (c || b) ? a : (c && b) : a，因为`&&`优先级比`||`高，而`||`优先级比`? :`高。

#### 结合性

```js
var a = foo() && bar();
```

从左到右的处理（JavaScript中的默认行为！）—— 它与`&&`的结合性无关。在这个例子中，因为这里只有一个`&&`因此没有相关的分组，所以根本谈不上结合性。

`a && b && c`将会作为`(a && b) && c`处理，因为`&&`是左结合的（顺带一提，`||`也是）。然而，右结合的`a && (b && c)`也表现出相同的行为。如果假设`&&`是右结合的，它就会与你手动使用`( )`建立`a && (b && c)`这样的分组的处理方式一样。但是这仍然不意味着`c`将会在`b`之前被处理。右结合性的意思不是从右到左求值，它的意思是从右到左分组。不管哪种方式，无论分组/结合性怎样，严格的求值顺序将是`a`，然后`b`，然后`c`（也就是从左到右）。

```js
a ? b : c ? d : e;
```

`? :`是右结合的，它将被处理的方式是`a ? b : (c ? d : e)`。

另一个右结合（分组）的例子是`=`操作符：

```js
var a, b, c;

a = b = c = 42;
```

它实际上这样看待这个语句：`a = (b = (c = 42))`。

```js
var a = 42;
var b = "foo";
var c = false;

var d = a && b || c ? c || b ? a : c && b : a;

d;		// 42
```

((a && b) || c) ? ((c || b) ? a : (c && b)) : a

### 自动分号

如果JS解析器在解析一行时发生了解析错误（缺少一个应有的`;`），而且它可以合理的插入一个`;`，它就会这么做。什么样的地方对插入是合理的？仅在一个语句和这一行的换行之间除了空格和/或注释没有别的东西时：

```js
var a = 42, b
c;
```

应当将下一行的`c`作为`var`语句的一部分看待吗？如果在`b`和`c`之间的任意一个地方出现一个`,`，它当然会的。但是因为没有，所以JS认为在`b`后面有一个隐含的`;`（在换行处）。如此`c;`就剩下来作为一个独立的表达式语句。

文法要求`do..while`循环后面要有一个`;`，但是`while`或`for`循环后面则没有。但是大多数开发者都不记得它！所以ASI帮助性地介入并插入一个：

```js
var a = 42;

do {
	// ..
} while (a)	// <-- 这里需要;！
a;
```

语句块儿不需要`;`终结，所以ASI是不必要的：

```js
var a = 42;

while (a) {
	// ..
} // <-- 这里不需要;
a;
```

另一个ASI介入的主要情况是，与`break`，`continue`，`return`，和（ES6）`yield`关键字：

```js
function foo(a) {
	if (!a) return
	a *= 2;
	// ..
}
```

这个`return`语句的作用不会超过换行到`a *= 2`表达式，因为ASI认为`;`终结了`return`语句。当然，`return`语句 *可以* 很容易地跨越多行，只要`return`后面不是除了换行外什么都没有就行：

```js
function foo(a) {
	return (
		a * 2 + 3 / 12
	);
}
```

### 错误

#### “早期错误”（编译期间）

任何直接的语法错误都是一个早期错误。因为你的代码还没有开始执行，这些错误不能使用`try..catch`捕获；它们只是会在你的程序进行解析/编译时导致失败。

一个简单的例子是正则表达式字面量中的语法。这里的JS语法没有错误，而是不合法的正则表达式将会抛出一个早期错误：

```js
var a = /+foo/;		// 错误！
```

一个赋值的目标必须是一个标识符（或者一个产生一个或多个标识符的ES6解构表达式），所以一个像`42`这样的值在这个位置上是不合法的，因此可以立即被报告：

```js
var a;
42 = a;		// 错误！
```

在`strict`模式中，函数参数的名称不能重复：

```js
function foo(a,b,a) { }					// 还好

function bar(a,b,a) { "use strict"; }	// 错误！
```

另一种`strict`模式的早期错误是，一个对象字面量拥有一个以上的同名属性：

```js
(function(){
	"use strict";

	var a = {
		b: 42,
		b: 43
	};			// 错误！
})();
```

从语义上讲，这样的错误技术上不是语法错误，而是文法错误 —— 上面的代码段是语法上合法的。但是因为没有`GrammarError`类型，一些浏览器使用`SyntaxError`代替。

TDZ指的是代码中还不能使用变量引用的地方，因为它还没有到完成它所必须的初始化：

```js
{
	a = 2;		// ReferenceError!
	let a;
}
```

赋值`a = 2`在变量`a`（它确实是在`{ .. }`块儿作用域中）被声明`let a`初始化之前就访问它，所以`a`位于TDZ中并抛出一个错误。虽然`typeof`有一个例外，它对于未声明的变量是安全的，但是对于TDZ引用却没有这样的安全例外：

```js
{
	typeof a;	// undefined
	typeof b;	// ReferenceError! (TDZ)
	let b;
}
```

### 函数参数值

ES6参数默认值会在数组`arguments`的值槽和相应的命名参数变量之间造成差异：

```js
function foo( a = 42, b = a + 1 ) {
	console.log(
		arguments.length, a, b,
		arguments[0], arguments[1]
	);
}

foo();					// 0 42 43 undefined undefined
foo( 10 );				// 1 10 11 10 undefined
foo( 10, undefined );	// 2 10 11 10 undefined
foo( 10, null );		// 2 10 null 10 null
```

即便参数默认值被应用到了参数`a`和`b`上，但是如果没有参数传入这些值槽，数组`arguments`也不会有任何元素。反过来，如果你明确地传入一个`undefined`参数，在数组`argument`中就会为这个参数存在一个元素，但它将是`undefined`，并且与同一值槽中的被命名参数将被提供的默认值不同。

这种脱节也会以诡异的方式发生在ES5中：

```js
function foo(a) {
	a = 42;
	console.log( arguments[0] );
}

foo( 2 );	// 42 (链接了)
foo();		// undefined (没链接)
```

如果你传递一个参数，`arguments`的值槽和命名的参数总是链接到同一个值上。如果你省略这个参数，就没有这样的链接会发生。在`strict`模式下，这种链接无论怎样都不存在了：

```js
function foo(a) {
	"use strict";
	a = 42;
	console.log( arguments[0] );
}

foo( 2 );	// 2 (没链接)
foo();		// undefined (没链接)
```

在ES6以前，要得到向另一个函数传递的所有参数值的数组，`arguments`是唯一的办法，它被证实十分有用。你也可以安全地混用被命名参数和`arguments`数组，只要你遵循一个简单的规则：绝不同时引用一个被命名参数和它相应的`arguments`值槽。

### `switch`

在表达式`a`和每一个`case`表达式之间的匹配与`===`算法是相同的。`switch`经常在`case`语句中使用绝对值，因此严格匹配是恰当的。你也许希望允许宽松等价（也就是`==`），而这么做你需要“黑”一下`switch`语句：

```js
var a = "42";

switch (true) {
	case a == 10:
		console.log( "10 or '10'" );
		break;
	case a == 42:
		console.log( "42 or '42'" );
		break;
	default:
		// 永远不会运行到这里
}
// 42 or '42'
```

这可以工作是因为`case`子句可以拥有任何表达式（不仅是简单值），这意味着它将用这个表达式的结果与测试表达式（`true`）进行严格匹配。因为这里`a == 42`的结果为`true`，所以匹配成功。`switch`的匹配本身依然是严格的，在这里是`true`和`true`之间。如果`case`表达式得出truthy的结果而不是严格的`true`，它就不会工作：

```js
var a = "hello world";
var b = 10;

switch (true) {
	case (a || b == 10):
		// 永远不会运行到这里
		break;
	default:
		console.log( "Oops" );
}
// Oops
```

因为`(a || b == 10)`的结果是`"hello world"`而不是`true`，所以严格匹配失败了。这种情况下，修改的方法是强制表达式明确成为一个`true`或`false`，比如`case !!(a || b == 10):`。

`default`子句是可选的，而且它不一定非要位于末尾（虽然那是一种强烈的惯例）。即使是在`default`子句中，是否遇到`break`的规则也是一样的：

```js
var a = 10;

switch (a) {
	case 1:
	case 2:
		// 永远不会运行到这里
	default:
		console.log( "default" );
	case 3:
		console.log( "3" );
		break;
	case 4:
		console.log( "4" );
}
// default
// 3
```

就像我们前面讨论的打标签的`break`，`case`子句内部的`break`也可以被打标签。这段代码的处理方式是，它首先通过所有的`case`子句，没有找到匹配，然后它回到`default`子句开始执行。因为这里没有`break`，它会继续走进已经被跳过的块儿`case 3`，在遇到那个`break`后才会停止。

### `try..finally`

`try`只要求`catch`和`finally`两者之一，虽然如果有需要它们可以同时出现。在`finally`子句中的代码总是运行的（无论发生什么），而且它总是在`try`（和`catch`，如果存在的话）完成后立即运行，在其他任何代码之前。从一种意义上说，你似乎可以认为`finally`子句中的代码是一个回调函数，无论块儿中的其他代码如何动作，它总是被调用：

```js
function foo() {
	try {
		return 42;
	}
	finally {
		console.log( "Hello" );
	}

	console.log( "never runs" );
}

console.log( foo() );
// Hello
// 42
```

`return 42`立即运行，它设置好`foo()`调用的完成值。这个动作完成了`try`子句而`finally`子句接下来立即运行。只有这之后`foo()`函数才算完成，所以被返回的完成值交给`console.log(..)`语句使用。对于`try`内部的`throw`说，行为是完全相同的：

```js
function foo() {
 try {
	 throw 42;
 }
 finally {
	 console.log( "Hello" );
 }

 console.log( "never runs" );
}

console.log( foo() );
// Hello
// Uncaught Exception: 42
```

如果一个异常从`finally`子句中被抛出（偶然地或有意地），它将会作为这个函数的主要完成值进行覆盖。如果`try`块儿中的前一个`return`已经设置好了这个函数的完成值，那么这个值就会被抛弃：

```js
function foo() {
	try {
		return 42;
	}
	finally {
		throw "Oops!";
	}

	console.log( "never runs" );
}

console.log( foo() );
// Uncaught Exception: Oops!
```

ES6在generator中增加了`yield`语句，generator从某些方面可以看作是中间的`return`语句。然而，和`return`不同的是，一个`yield`在generator被推进前不会完成，这意味着`try { .. yield .. }`还没有完成。所以附着在其上的`finally`子句将不会像它和`return`一起时那样，在`yield`之后立即运行。

一个在`finally`内部的`return`有着覆盖前一个`try`或`catch`子句中的`return`的特殊能力，但是仅在`return`被明确调用的情况下：

```js
function foo() {
	try {
		return 42;
	}
	finally {
		// 这里没有 `return ..`，所以返回值不会被覆盖
	}
}

function bar() {
	try {
		return 42;
	}
	finally {
		// 覆盖前面的 `return 42`
		return;
	}
}

function baz() {
	try {
		return 42;
	}
	finally {
		// 覆盖前面的 `return 42`
		return "Hello";
	}
}

foo();	// 42
bar();	// undefined
baz();	// "Hello"
```
